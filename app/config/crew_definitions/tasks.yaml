triage_initial_message_task:
  description: |
    Você é o TriageAgent. Analise a mensagem do cliente fornecida no input:
    - Mensagem: "{message_text}"
    - ID Contato: "{contact_id}"
    - ID Chat: "{chat_id}"
    - Timestamp: "{timestamp}"

    Siga seu FLUXO DE ANÁLISE E DECISÃO:
    1. Consulte caches L0/L1 (via L1CacheQueryTool).
    2. Consulte a Base de Conhecimento L2 - Qdrant (via FastMemoryMessages).
    3. Decida se uma RESPOSTA IMEDIATA é viável.
       - Se sim, prepare a(s) mensagem(ns) para envio direto (via CallbellSendTool) e defina "action": "RESPONDED_DIRECTLY".
    4. Se não houver resposta imediata, determine a INTENÇÃO PRINCIPAL, TÓPICO e CONTEXTO OPERACIONAL.
       - Defina "action": "INITIATE_FULL_PROCESSING".
    Retorne APENAS um objeto JSON com os campos especificados na sua SAÍDA ESPERADA.
  expected_output: |
    {
      "action": "RESPONDED_DIRECTLY" | "INITIATE_FULL_PROCESSING",
      "message_text_original": "message_text",
      "contact_id": "contact_id",
      "chat_id": "{chat_id}",
      "identified_topic": "identified_topic",
      "operational_context": "operational_context",
      "direct_response_messages": [mensagens] - se RESPONDED_DIRECTLY,
      "requires_profiling": true - se INITIATE_FULL_PROCESSING
    }

profile_customer_task:
  description: |
    Você é o CustomerProfiler. O TriageAgent decidiu por "INITIATE_FULL_PROCESSING".
    Dados recebidos (contexto da tarefa anterior):
    - ID Contato: "{contact_id}" (Extraído do output da tarefa de triagem)
    - ID Chat: "{chat_id}" (Extraído do output da tarefa de triagem)
    - Mensagem Original: "{message_text_original}" (Extraído do output da tarefa de triagem)
    - Contexto Operacional: "{operational_context}" (Extraído do output da tarefa de triagem)

    Siga seu FLUXO DE CONSTRUÇÃO DE PERFIL:
    1. Use a GetUserProfile com o contact_id para buscar o histórico de interações e informações relevantes do cliente.
    2. Analise se o perfil já existe ou se é necessário criar um novo.
    3. Se o perfil não existir, crie um novo perfil com base na mensagem original e no histórico, tente inferir informações relevantes.
    4. Se o perfil já existir, atualize-o com as informações da mensagem original e do histórico.
    5. Consolide as informações em um sumário e perfil detalhado.
       - Inclua compras passadas, tickets de suporte, sentimento atual, estágio de vendas e preferências.
    6. Salve o perfil atualizado usando a SaveUserProfile, passando seu json resposta para a ferramenta.

    Retorne APENAS um objeto JSON com os campos especificados na sua SAÍDA ESPERADA.
  expected_output: |
    {
      "contact_id": ID do contato,
      "profile_summary": Sumário do perfil,
      "detailed_profile": { "past_purchases": [], "support_tickets": [], "current_sentiment": "...", "sales_stage": "...", "preferences": [] },
      "operational_context": (SALES, SUPPORT, etc.)
    }

develop_strategy_task:
  description: |
    Você é o StrategicAdvisor. Dados recebidos (contexto das tarefas anteriores):
    - Perfil do Cliente (JSON): "{profile_customer_task.output}"
    - Mensagem Original do Cliente: "{message_text_original}"
    - Contexto Operacional: "{operational_context}"
    - Tópico Identificado: "{identified_topic}"

    Siga sua FILOSOFIA DE CONSULTORIA ESTRATÉGICA e FLUXO DE DEFINIÇÃO DE ESTRATÉGIA:
    1. Analise todos os inputs.
    2. Use a BusinessGuidelinesTool para buscar as diretrizes relevantes para o contexto operacional.
    3. Use a RAGTool juntamente com a técnica HyDE para conseguir extrair informações valiosas da nossa base de dados vetorial Qdrant. 
    4. Formule o plano estratégico (objetivo, pontos-chave, perguntas, necessidade de ação de sistema).
       - Adapte a estratégia se o contexto for SALES (Alessandro) ou SUPPORT (Sofia).

    Retorne APENAS um objeto JSON com os campos especificados na sua SAÍDA ESPERADA.
  expected_output: |
    {
      "strategy_type": (ex: "SALES_QUALIFICATION", "SUPPORT_TROUBLESHOOTING"),
      "conversation_goal": Descrição do objetivo,
      "key_talking_points": [argumentos/informações],
      "questions_to_ask_client": [perguntas],
      "system_action_request": { "action_type": "...", "parameters": {...} } ou null,
      "internal_notes_for_craftsman": "Instruções de tom, estilo, foco.",
      "empathy_statement_suggestion": (Opcional, para Suporte) "Sugestão de frase empática inicial.",
      "super_message": (OBRIGATÓRIO) "Uma super mensagem de muitos parágrafos rica em informação para ser meticulosamente usada pelo ResponseCraftsman"

    }

execute_system_operations_task:
  description: |
    Você é o SystemOperationsAgent. Dados recebidos (contexto da tarefa anterior):
    - Solicitação de Ação de Sistema (JSON): "{develop_strategy_task.output.system_action_request}"

    Verifique se `system_action_request` não é nulo e contém `action_type` e `parameters`.
    Se for nulo ou inválido, retorne: {"action_type_executed": "NONE", "status": "no_action_requested", "data": null, "error_message": null}

    Caso contrário, siga seu FLUXO DE EXECUÇÃO DE AÇÃO DE SISTEMA:
    1. Mapeie o `action_type` para a ferramenta InternalAPITool_* correta.
    2. Execute a ferramenta com os `parameters`.
    Retorne APENAS um objeto JSON com os campos especificados na sua SAÍDA ESPERADA.
  expected_output: |
    {
      "action_type_executed": O `action_type` que foi processado,
      "status": "success" ou "error",
      "data": { ...dados retornados pela API... } (se sucesso),
      "error_message": "Detalhes do erro" (se error)
    }

craft_response_task:
  description: | # - Resultado da Ação de Sistema (JSON, pode ser nulo): "{execute_system_operations_task.output}"
    Você é o ResponseCraftsman. Dados recebidos (contexto das tarefas anteriores):
    - Plano Estratégico (JSON): "{develop_strategy_task.output}"
    - Perfil do Cliente (JSON): "{profile_customer_task.output}"
    - Contexto Operacional: "{operational_context}"
    - Tópico Identificado: "{identified_topic}"
    - Mensagem Original do Cliente: "{message_text_original}"
    
    Siga seus PRINCÍPIOS DE COMUNICAÇÃO GLOBAL SYSTEM e FLUXO DE CRIAÇÃO DE RESPOSTA:
    1. Analise todos os inputs, especialmente as "internal_notes_for_craftsman" do plano estratégico.
    2. Gere as mensagens principais, fragmentando se necessário.
    3. Gere conteúdo proativo (perguntas/respostas) para a Base de Conhecimento.
       (Este conteúdo será passado para a SaveFastMemoryMessages pela lógica do CrewAI após sua tarefa,
        você apenas gera o conteúdo no formato esperado).
    4. Se o `super_message` estiver presente, use-o como base para criar uma resposta rica e informativa.
    5. Tente focar as informações recebidas na mensagem do cliente, no contexto e no tópico identificado para criar mensagens relevantes para o que o cliente precisa.

    Retorne APENAS um objeto JSON com "primary_messages_sequence" e "proactive_content_generated".
  expected_output: |
    {
      "primary_messages_sequence": [ "Mensagem 1...", "Mensagem 2...", ... ],
      "proactive_content_generated": [ { "question": "...", "answer": "..." }, ... ],
    }

coordinate_delivery_task:
  description: |
    Você é o DeliveryCoordinator. Dados recebidos (contexto das tarefas anteriores):
    - Sequência de Mensagens Primárias: "{craft_response_task.output.primary_messages_sequence}"
    - ID Contato: "{triage_initial_message_task.output.contact_id}"
    - ID Chat: "{triage_initial_message_task.output.chat_id}"

    Siga seus PRINCÍPIOS DE ENTREGA E COORDENAÇÃO e FLUXO DE ENTREGA COORDENADA:
    1. Use a ConversationStateTool para registrar as mensagens pendentes.
    2. Envie cada mensagem da sequência cadenciadamente usando a CallbellSendTool.
    3. Atualize o estado na ConversationStateTool após cada envio.
    4. (Lógica de tratamento de interrupção é complexa e pode ser gerenciada pelo reinício do ciclo pelo TriageAgent).
       Se a entrega for concluída, retorne "COMPLETED". Se houver falha no envio, "FAILED_TO_SEND".
    Retorne APENAS um objeto JSON com os campos especificados na sua SAÍDA ESPERADA.
  expected_output: |
    {
      "delivery_status": "COMPLETED" ou "INTERRUPTED_BY_CLIENT" ou "FAILED_TO_SEND",
      "messages_sent_count": número de mensagens efetivamente enviadas da sequência,
      "remaining_messages_in_queue": [mensagens que não foram enviadas devido à interrupção] (se interrompido),
      "new_client_message_text_that_interrupted": (Opcional, se o sistema puder prover essa informação diretamente à tarefa)
    }