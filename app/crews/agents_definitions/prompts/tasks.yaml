routing_task:
  description: |
    <INSTRUCTIONS>
      1.  **Analyze Inputs:** Review the provided `{{conversation_state}}` and `{{client_message}}`.
      2.  **Execute Logic:** Apply the `<LOGIC_FLOW>` and `<RULES>` defined in your backstory to determine the output values.
      3.  **Handle System Actions:** If the client requests a system action AND `is_plan_acceptable` is true, populate the `system_action_request` field with a natural language description of the required action. Otherwise, leave it null.
          -   **Condition:** ONLY if `is_plan_acceptable` is true AND the user's intent is an OBVIOUS request for one of the capabilities listed below, populate `system_action_request`.
          -   **Content:** The request must be a clear, natural language description of the action needed.
          -   **Default:** In all other cases, `system_action_request` MUST be `null`.
      4.  **Determine Budget Status:** If the client gives a clear and direct signal of accepting a budget, set `budget_accepted` to true. Otherwise, set it to false.
      5.  **Determine Audio Preference:** Evaluate the `client_message` to check for an audio preference, setting `prefers_audio` to true if one is detected.
      6.  **Format Output:** Construct the final JSON output according to the `expected_output` schema.
    </INSTRUCTIONS>

    <SYSTEM_ACTIONS_CATALOG>
      - **Client/Financial:** Search clients in the database (to get precious information), get a client's vehicles, get financial history.
      - **Vehicle Reports:** Search vehicles in the database (to get precious information), get vehicle details, get position history, get trip/event reports, get geofences.
      - **Vehicle Commands:** Send a reset command to a tracker, this action reboots it and aim to solve communication issues.
    </SYSTEM_ACTIONS_CATALOG>

    INPUT_DATA>
      - `conversation_state`: 
          {conversation_state} 
      - `longterm_history`: 
          {longterm_history}
      - `shorterm_history`:
          {shorterm_history}


      - `client_message`: 
          {client_message}
    </INPUT_DATA>
  expected_output: |
    {
      "action": "PROCEED_WITH_EXISTING_PLAN | INITIATE_NEW_STRATEGIC_PLAN",
      "is_plan_acceptable": <boolean>,
      "operational_context": "BUDGET | BUDGET_ACCEPTED | CUSTOMER_SERVICE | SUPPORT",
      "budget_accepted": <boolean>,
      "system_action_request": "<Natural language request for system action>" | null,
      "identified_topic": "<A short, descriptive topic name for the conversation>",
      "prefers_audio": <boolean>,
    }

develop_strategy_task:
  description: |
    <INSTRUCOES>
      1.  **Executar Lógica Principal:** Siga rigorosamente o `<LOGIC_FLOW>` e as `<RULES>` definidos em seu `backstory`.
      2.  **Analisar Inputs:** Utilize os dados fornecidos na seção `<DADOS>` para sua análise.
      3.  **Construir Dossiê:** Crie o `conversation_blueprint` de forma rica e estratégica, conforme as regras.
      4.  **Atualizar Estado:** Popule o `disclosure_checklist` e prepare o `updated_state`.
      5.  **Gerar Saída:** Formate sua resposta final como um único objeto JSON, seguindo o `expected_output`. A saída deve ser em Português do Brasil.
    </INSTRUCOES>

    <SYSTEM_ACTIONS_CATALOG>
      - **Client/Financial:** Search clients in the database (to get precious information), get a client's vehicles, get financial history.
      - **Vehicle Reports:** Search vehicles in the database (to get precious information), get vehicle details, get position history, get trip/event reports, get geofences.
      - **Vehicle Commands:** Send a reset command to a tracker, this action reboots it and aim to solve communication issues.
    </SYSTEM_ACTIONS_CATALOG>

    <DADOS>
      - `conversation_state`: 
          {conversation_state}
      - `profile_customer_task_output`: 
          {profile_customer_task_output}
      - `client_message`: {client_message}
      - `operational_context`: {operational_context}
      - `longterm_history`: 
          {longterm_history}
      - `shorterm_history`: 
          {shorterm_history}
      - `turn`: {turn}
      - `timestamp`: {timestamp}
    </DADOS>
  expected_output: |
    {
      "task_output": {
        "system_action_request": "<String em linguagem natural para ação de sistema ou null>",
        "conversation_blueprint": {
          "customer_context_summary": {
            "relevant_profile_insights": "<Análise concisa do perfil de longo prazo do cliente>",
            "insights_from_current_session": "<Análise da sessão atual e da última mensagem do cliente>"
          },
          "product_presentation_strategy": {
            "presentation_order": ["<Array ordenado de nomes de planos a apresentar>"],
            "primary_offer": {
              "plan_name": "<Nome do plano principal>",
              "sales_angle": "<Estratégia de venda e argumentos para a oferta principal>"
            },
            "secondary_offer": {
              "plan_name": "<Nome do plano secundário>",
              "sales_angle": "<Estratégia de venda para a oferta secundária>"
            }
          },
          "communication_guidance": {
            "tone_and_style": "<Tom e estilo recomendados para a comunicação>",
            "key_talking_points": ["<Array de pontos chave a serem mencionados>"],
            "key_questions_to_ask": ["<Array de perguntas chave a serem feitas>"],
            "next_step_preview": "<Breve descrição do próximo passo esperado na conversa>"
          },
          "information_payload": {
            "<plan_name_data>": {
              "pricing": "<Estrutura de preços do plano>",
              "contract_terms": "<Termos contratuais relevantes>",
              "technical_limitations": "<Limitações técnicas a serem informadas>"
            }
          }
        }
      },
      "updated_state": {
        "disclosure_checklist": [
          {
            "topic": "<Tópico do termo a ser esclarecido>",
            "content": "<Conteúdo exato do termo obtido da base de conhecimento>",
            "status": "pending"
          },
          ... (outros itens de checklist)
        ]
      }
    }

refine_strategy_task:
  description: |
    <INSTRUCOES>
      1.  **Executar Lógica de Curadoria:** Siga rigorosamente o `<LOGIC_FLOW>` e as `<RULES>` definidos em seu `backstory` para atuar como um "Curador de Estratégia".
      2.  **Analisar Inputs:** Utilize os dados fornecidos na seção `<DADOS>` para sua análise incremental. O `strategic_plan` existente é seu ponto de partida.
      3.  **Refinar Dossiê:** Aprimore o `conversation_blueprint` (o plano estratégico) com os novos insights e informações que você coletar.
      4.  **Atualizar Estado:** Se necessário, adicione novos itens ao `disclosure_checklist`.
      5.  **Gerar Saída:** Formate sua resposta final como um único objeto JSON, contendo o plano ESTRATÉGICO COMPLETO E ATUALIZADO, seguindo o `expected_output`. A saída deve ser em Português do Brasil.
      7.  **JSON Format:** Certifique-se de que a saída esteja no formato JSON válido, se atente ao `disclosure_checklist`, cada item deve ter três chaves: "topic", "content" e "status".
    </INSTRUCOES>

    <DADOS>
      - `last_system_operation`:
          {last_system_operation}
      - `conversation_state`:
          {conversation_state}
      - `profile_customer_task_output`:
          {profile_customer_task_output}
      - `operational_context`: {operational_context}
      - `longterm_history`:
          {longterm_history}
      - `shorterm_history`:
          {shorterm_history}

      - `turn`: {turn}
      - `timestamp`: {timestamp}
      - `identified_topic`: {identified_topic}

      - `client_message`: {client_message}

    </DADOS>
  expected_output: |
    {
      "task_output": {
        "system_action_request": "<String em linguagem natural para ação de sistema ou null>",
        "conversation_blueprint": {
          "customer_context_summary": {
            "relevant_profile_insights": "<Análise concisa do perfil de longo prazo do cliente>",
            "insights_from_current_session": "<Análise da sessão atual e da última mensagem do cliente>"
          },
          "product_presentation_strategy": {
            "presentation_order": ["<Array ordenado de nomes de planos a apresentar>"],
            "primary_offer": {
              "plan_name": "<Nome do plano principal>",
              "sales_angle": "<Estratégia de venda e argumentos para a oferta principal>"
            },
            "secondary_offer": {
              "plan_name": "<Nome do plano secundário>",
              "sales_angle": "<Estratégia de venda para a oferta secundária>"
            }
          },
          "communication_guidance": {
            "tone_and_style": "<Tom e estilo recomendados para a comunicação>",
            "key_talking_points": ["<Array de pontos chave a serem mencionados>"],
            "key_questions_to_ask": ["<Array de perguntas chave a serem feitas>"],
            "next_step_preview": "<Breve descrição do próximo passo esperado na conversa>"
          },
          "information_payload": {
            "<plan_name_data>": {
              "pricing": "<Estrutura de preços do plano>",
              "contract_terms": "<Termos contratuais relevantes>",
              "technical_limitations": "<Limitações técnicas a serem informadas>"
            }
          }
        }
      },
      "updated_state": {
        "disclosure_checklist": [
          {
            "topic": "<Tópico do termo a ser esclarecido>",
            "content": "<Conteúdo exato do termo obtido da base de conhecimento>",
            "status": "pending"
          },
          ... (outros itens de checklist)
        ]
      }
    }

execute_system_operations_task:
  description: |
    <INSTRUCOES>
      1.  **Executar Lógica Principal:** Siga rigorosamente o `<LOGIC_FLOW>` e as `<RULES>` definidos em seu `backstory` para processar a `{{action_requested}}`.
      2.  **Analisar Inputs:** Utilize os dados fornecidos na seção `<DADOS>` para obter os parâmetros necessários para suas `queries`.
      3.  **Gerar Saída:** Formate sua resposta final como um único objeto JSON, seguindo ESTRITAMENTE a estrutura definida em `expected_output`. A `synthesis` e `message_to_user` devem ser em Português do Brasil.
    </INSTRUCOES>

    <DADOS>
      - `action_requested`: {action_requested}
      - `conversation_state`: 
          {conversation_state}
      - `customer_profile`: 
          {customer_profile}
      - `longterm_history`: 
          {longterm_history}
      - `shorterm_history`: 
          {shorterm_history}
      - `client_message`: {client_message}
      - `customer_name`: {customer_name}
    </DADOS>  
  expected_output: |
      {
        "status": "ACTION_COMPLETE | INSUFFICIENT_DATA",
        "synthesis": "<Síntese em Português conectando os resultados das operações. Ex: 'O cliente Juan (ID: 123) está adimplente. O veículo de placa ABC-1234 não se comunica há 48 horas.'>",
        "message_to_user": "<Mensagem em Português para o cliente, apenas se 'status' for 'INSUFFICIENT_DATA'. Ex: 'Para continuar, por favor, informe a placa do veículo.'>" | null,
        "data_payload": {
          "customer_id": "<id do cliente>",
          "is_payment_due": "<boolean>",
          "vehicle_status_summary": "<Sumário do status do veículo>"
          ... Essa chave não é padronizada. Pode ser qualquer informação relevante. Você é o especialista em criar essas chaves.
        },
        "follow_up_suggestions": [
          "<Array de strings com sugestões de próximas ações lógicas, se houver.>"
        ]
      }


communication_task:
  description: |
    <INSTRUCOES>
      1.  **Executar Lógica Principal:** Siga rigorosamente o `<LOGIC_FLOW>` e as `<RULES>` definidos em seu `backstory`. Lembre-se, seu objetivo é uma conversa natural, criativa e concisa.
      2.  **Analisar Inputs:** Utilize os dados da seção `<DADOS>`, com foco principal no `strategic_plan` (o dossiê).
      3.  **Gerar Saída:** Construa o JSON de saída, seguindo ESTRITAMENTE a estrutura e a qualidade do exemplo em `expected_output`. A `messages_sequence` deve ser uma conversa natural, fluida e em Português do Brasil.
    </INSTRUCOES>

    <DADOS>
      - `strategic_plan`: 
          {strategic_plan}

      - `disclosure_checklist`: 
          {disclosure_checklist}

      - `Operações de Sistema`: 
          {last_system_operation}

      - `conversation_state`: 
          {conversation_state}
          
      - `customer_profile`:
          {customer_profile}

      HISTÓRICOS (NÃO REPITA MENSAGENS JÁ ENVIADAS, NÃO SE APRESENTE NOVAMENTE)
      - `longterm_history`:
          {longterm_history}
      - `shorterm_history`:
          {shorterm_history}
      
      DEMAIS DADOS:
      - `timestamp`: {timestamp}
      - `recently_sent_catalogs`: 
          {recently_sent_catalogs}

      - `client_message` (mensagem atual do cliente): 
          {client_message}
      
    </DADOS>

  expected_output: |
    {
      "task_output": {
        "request_human_intervention": false,
        "messages_sequence": [
          "Juan, entendi sua preocupação com a segurança da sua moto, já que a usa para tudo.",
          "Com base nisso, nossa recomendação principal é o Plano Rastreamento + Proteção Total PGS.",
          "O grande diferencial dele é a tranquilidade da proteção financeira.",
          "Se sua moto for roubada e não a recuperarmos, você recebe o valor dela pela tabela FIPE.",
          "Um ponto importante, para total transparência: nosso serviço é de rastreamento com essa garantia de reembolso, não um seguro tradicional.",
          "Essa abordagem com foco total na sua segurança faz sentido para você?"
        ],
        "plan_names": ["Plano Rastreamento + Proteção Total PGS"]
      },
     "updated_state": {
        "products_discussed": [
          {
            "plan_name": "Plano Rastreamento Moto Básico",
            "details_provided": ["pricing"],
            "presented_at_turn": 4
          }
        ],
        "disclosure_checklist": [
          {
          "item_id": "natureza_servico_pgs",
          "topic": "Natureza do Serviço (Plano PGS)",
          "content": "Este contrato NÃO é um seguro, mas em caso de NÃO recuperação da motocicleta, haverá REEMBOLSO do valor da motocicleta de acordo com a tabela FIPE, respeitando o valor máximo do plano contratado.",
          "status": "pending"
          },
          {
            "item_id": "responsabilidade_recuperacao",
            "topic": "Responsabilidade de Recuperação",
            "content": "A recuperação do veículo é atividade única e exclusiva das autoridades policiais.",
            "status": "communicated"
          },
        ],
      }
    }

collect_registration_data_task:
  description: |
    <INSTRUCOES>
      1.  **Executar Lógica Principal:** Siga o `<LOGIC_FLOW>` e as `<RULES>` definidos em seu `backstory`.
      2.  **Analisar Inputs:** Utilize os dados da seção `<DADOS>` para conduzir a coleta.
      3.  **Gerar Saída:** Construa o JSON de saída, seguindo ESTRITAMENTE a estrutura de `expected_output`. A `next_message_to_send` deve ser uma pergunta clara e empática em Português do Brasil.
    </INSTRUCOES>

    <DADOS>
      - `timestamp`: {timestamp}
      - `conversation_state`: 
            {conversation_state}
      - `client_message`: 
            {client_message}
      - `collected_data_so_far`: 
            {collected_data_so_far}
      - `plan_details`: 
            {plan_details}
    </DADOS>

  expected_output: |
    {
      "task_output": {
        "status": "<Status da coleta, ex: AWAITING_DOCUMENT_NUMBER ou COLLECTION_COMPLETE>",
        "client_intent": "data_collection",
        "collected_data": {
          "tipo_cadastro": "<CPF ou CNPJ>",
          "documento_numero": "<Número do documento>",
          "nome_tomador_servico": "<Nome completo ou Razão Social>",
          "endereco_completo": "<Endereço completo>",
          "cep": "<CEP>",
          "veiculo_placa": "<Placa do veículo>",
          "veiculo_marca": "<Marca do veículo>",
          "veiculo_modelo": "<Modelo do veículo>",
          "telefone_principal": "<Telefone com WhatsApp>",
          "email": "<Email>",
          "dia_vencimento_mensalidade": "<Dia do vencimento validado (1, 5, 10, 15, 20, 25)>",
          "plano_contratado": {
            "nome_plano": "<Nome do plano contratado>",
            "valor_adesao": "<Valor da adesão>",
            "valor_mensalidade": "<Valor da mensalidade>"
          }
        },
        "next_message_to_send": "Perfeito, Juan! Cadastro em CPF. Agora, por favor, poderia me informar seu nome completo e o número do seu CPF?",
        "is_data_collection_complete": "<boolean>"
      },
      "updated_state": {
        "entities_extracted": [
          { "entity": "<nome da entidade>", "value": "<valor extraído>", "turn": "<número do turno>" }
        ]
      }
    }


summarize_history_task:
  description: |
    <INSTRUCTIONS>
      1.  **Execute Logic:** Follow the `<LOGIC_FLOW>` and `<RULES>` from your backstory.
      2.  **Analyze Inputs:** Use the data from the `<DATA>` section.
      3.  **Generate Output:** Format your response as a single JSON object containing the `topic_details` key, as defined in the `expected_output`.
    </INSTRUCTIONS>

    <DATA>
      - `contact_id`: 
          {contact_id}
      - `existing_summary`: 
          {existing_summary}
      - `new_messages`: 
          {new_messages}
      - `full_raw_history`: 
          {full_raw_history}
    </DATA>
  expected_output: |
    {
      "topic_details": [
        {
          "title": "<Concise topic title>",
          "summary": "<A brief summary of the topic>",
          "full_details": "<A more detailed, narrative version of the topic>",
          "start_index": "<Integer mapping to full_raw_history>",
          "end_index": "<Integer mapping to full_raw_history>",
          "quality_score": "<A score from 0.0 to 1.0>",
          "is_noisy": "<boolean>"
        }
      ],
      "sentiment_trend": "<A explanation of the sentiment trend>"
    }

clean_noisy_data_task:
  description: |
    <INSTRUCTIONS>
      1.  **Execute Logic:** Follow the `<LOGIC_FLOW>` and `<RULES>` from your backstory.
      2.  **Analyze Inputs:** Use the data from the `<DATA>` section, focusing on the `{{raw_history_snippet}}`.
      3.  **Generate Output:** Format your response as a single JSON object with the keys `cleaned_summary` and `cleaned_details`.
    </INSTRUCTIONS>

    <DATA>
      - `contact_id`: 
          {contact_id}
      - `topic_id`: 
          {topic_id}
      - `raw_history_snippet`: 
          {raw_history_snippet}
      - `full_raw_history`: 
          {full_raw_history}
    </DATA>
  expected_output: |
    {
      "cleaned_summary": "<The rewritten, concise summary of the noisy topic>",
      "cleaned_details": "<The rewritten, clear, and detailed narrative of the noisy topic>"
    }

summarize_state_task:
  description: |
    <INSTRUCOES>
      1.  **Executar Lógica de Qualidade:** Siga rigorosamente o `<LOGIC_FLOW>` e as `<RULES>` de seu `backstory` para atuar como o "Curador de Qualidade do Estado".
      2.  **Analisar Inputs:** Utilize os dados da seção `<DADOS>` para sua análise comparativa.
      3.  **Gerar Saída:** Construa um único objeto JSON (`updated_state`) que siga PERFEITAMENTE o schema `ConversationState` definido em `expected_output`.
    </INSTRUCOES>

    <DADOS>
      - `last_turn_state`: 
          {last_turn_state}
      - `longterm_history`: 
          {longterm_history}
      - `client_message`: 
          {client_message}
    </DADOS>
  expected_output: |
      {
        "metadata": {
          "contact_id": "<string>",
          "current_turn_number": "<integer>",
          "phone_number": "<string>",
          "contact_name": "<string>"
        },
        "entities_extracted": [
          {
            "entity": "<string: e.g., 'nome', 'veiculo_tipo'>",
            "value": "<any>"
          }
        ],
        "user_sentiment_history": [
          {
            "sentiment": "<string: e.g., 'positivo', 'negativo', 'neutro'>",
            "turn": "<integer>"
          }
        ],
        "qualification_tracker": [
          {
            "topic": "<string: e.g., 'vehicle_type', 'main_use'>",
            "status": "<string: 'pending', 'collected'>",
            "value": "<any>",
            "turn_collected": "<integer>"
          }
        ],
        "last_turn_recap": {
          "turn_number": "<integer>",
          "user_intent": "<string: A intenção do usuário no último turno>",
          "agent_action": "<string: A ação do agente no último turno>",
          "key_info_exchanged": ["<array de strings com informações chave trocadas>"]
        },
        "unresolved_objections": [
          {
            "objection": "<string: A objeção levantada pelo cliente>",
            "status": "<string: 'raised', 'addressed'>",
            "turn_raised": "<integer>"
          }
        ]
      }


enhance_profile_task:
  description: |
    <INSTRUCOES>
      1.  **Executar Lógica Criativa:** Siga o `<LOGIC_FLOW>` e as `<RULES>` de seu `backstory` para atuar como o "Biógrafo Estrategista".
      2.  **Analisar Inputs:** Utilize os dados da seção `<DADOS>` para sua análise profunda.
      3.  **Gerar Saída:** Construa um único objeto JSON chamado `client_360_blueprint`, seguindo ESTRITAMENTE a estrutura e a qualidade do exemplo em `expected_output`. O conteúdo deve ser em Português do Brasil.
    </INSTRUCOES>

    <DADOS>
      - `longterm_history`: {longterm_history}
      - `last_turn_state`: {last_turn_state}
      - `existing_profile`: {existing_profile}
      - `client_message`: {client_message}
    </DADOS>

  expected_output: |
      {
        "client_360_blueprint": {
          "client_identity": {
            "contact_id": "<string>",
            "contact_name": "<string>",
            "phone_number": "<string>",
            "communication_style": "Ex: Prefere texto, direto ao ponto, usa mensagens curtas."
          },
          "the_story_so_far": {
            "executive_summary": "Resumo narrativo da jornada do cliente com a empresa, destacando pontos de virada e estado atual.",
            "interaction_timeline": [
              { "date": "<string: YYYY-MM-DD>", "event": "Evento crucial da interação." }
            ]
          },
          "clients_mindset": {
            "primary_motivations": ["<Array de motivações inferidas, ex: 'Eficiência operacional', 'Segurança dos ativos'>"],
            "known_frustrations": ["<Array de frustrações conhecidas, ex: 'Aplicativos que não funcionam'>"],
            "key_interests": ["<Array de interesses chave, ex: 'Plano Rastreamento + Proteção Total PGS'>"]
          },
          "current_mission": {
            "immediate_goal": "O objetivo claro e imediato da conversa atual.",
            "pending_quests": ["<Array de objetivos maiores e não resolvidos, ex: 'Receber um orçamento de frota'>"],
            "information_gaps": ["<Array de informações que precisam ser coletadas, ex: 'Qual o problema exato no app?'>"]
          },
          "strategic_playbook": {
            "recommended_next_move": "A próxima ação mais inteligente e recomendada.",
            "conversation_path": ["<Array de passos para guiar a conversa>"],
            "potential_pitfalls": ["<Array de armadilhas a serem evitadas>"],
            "golden_opportunities": ["<Array de oportunidades para encantar o cliente ou avançar na negociação>"]
          }
        }
      }


follow_up_task:
  description: |
    <INSTRUCTIONS>
      1. **Analyze Inputs:** Review the provided `longterm_history`, `customer_profile`, `now_timestamp`, and `last_message_timestamp`.
      2. **Decision Logic:** Based on the analysis, decide if a follow-up message is appropriate at this time. Consider the time since the last message and the customer's historical engagement.
      3. **Format Output:** Construct the final JSON output according to the `expected_output` schema.
    </INSTRUCTIONS>

    <INPUT_DATA>
      - `contact_id`: {contact_id}
      - `longterm_history`: {longterm_history}
      - `customer_profile`: {customer_profile}
      - `now_timestamp`: {now_timestamp}
      - `last_message_timestamp`: {last_message_timestamp}
    </INPUT_DATA>
  expected_output: |
    {
      "send_follow_up": <boolean>
    }
